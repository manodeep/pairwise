{"name":"Pairwise","tagline":"","body":"[![MIT licensed](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/manodeep/pairwise/master/LICENSE)\r\n[![DOI](https://zenodo.org/badge/19184/manodeep/pairwise.svg)](https://zenodo.org/badge/latestdoi/19184/manodeep/pairwise)\r\n\r\n# Description\r\n\r\nThis repo contains a set of codes to benchmark various methods that\r\ngenerate all pairwise separations. The work was inspired\r\n(read, challenge accepted) by the blog post by Jake VanderPlas\r\n[here](https://jakevdp.github.io/blog/2013/06/15/numba-vs-cython-take-2/).\r\n\r\n# Installation\r\nCurrently requires [ispc](http://ispc.github.io). If ispc is in your PATH, then installation be as simple as make. See [INSTALL](https://raw.githubusercontent.com/manodeep/pairwise/master/INSTALL) for further details.\r\n\r\n## AllPairwise\r\n\r\nThe main code is ``pairwise_3d.c`` -- this contains a set of functions\r\nthat compute all pair-wise separations for two sets of ``N`` random\r\nfloating point numbers. \r\n\r\n``pairwise_3d.ispc`` contains the [ispc](http://ispc.github.io/) code to compute\r\nall pairwise separations. Spoiler alert: ispc seems to produce the fastest\r\nfunction for a variety of N. \r\n\r\n``pairwise_3d.f90`` contains the fortran routine to compute the same\r\npairwise separations in fortran. Taken straight from the comments in the\r\nblog link above and edited to show reasonable run times. \r\n\r\n\r\n``pairwise.c`` contains similar functions as ``pairwise_3d.c`` except that the\r\narray storage is now ``xyzxyz...`` rather than ``xxx...yyy...zzz..`` . This\r\n``pairwise`` also contains the oft-touted BLAS way of computing pairwise\r\nseparations. Notably, ``pairwise`` is about 2-3 times slower than ``pairwise_3d``,\r\nagreeing with what we expect from array of structure vs structure of arrays \r\narguments (AOS vs SOA). \r\n\r\n### Performance Table\r\n\r\nPerforming 1000 iterations over 2 sets with 1000 elements each. So, a total computation\r\nof 1 million squared-distances, averaged over (at most) 1000 iterations. Each test is\r\nrepeated 5 times and the best average time is noted here. \r\n\r\nFunction                         |  gcc timings (ms)| icc timings (ms) | clang timings (ms)|\r\n---------------------------------|------------------|------------------|-------------------|\r\nnaive                            |   0.56 +-  0.01  |   0.53 +-  0.00  |   0.53 +-  0.01   | \r\nchunked                          |   0.57 +-  0.00  |   0.57 +-  0.01  | \t 0.55 +-  0.01   |\r\ncompiler_vectorized_chunked      |   1.45 +-  0.01  |   0.60 +-  0.01  | \t 1.54 +-  0.00   |\r\nintrinsics_chunked               |   0.50 +-  0.01  |   0.63 +-  0.01  | \t 0.52 +-  0.01   |\r\nintrinsics_chunked_unroll2       |   0.49 +-  0.00  |   0.59 +-  0.01  | \t 0.53 +-  0.00   |\r\npairwise_ispc                    |   0.62 +-  0.01  |   0.63 +-  0.01  | \t 0.63 +-  0.01   |\r\n\r\n\r\nNow, the same table just that the distances are square-rooted. Since, square-root is a\r\nvery expensive operation, the timings are about a factor of 5 larger on average. \r\n\r\n\r\nFunction                         |  gcc timings (ms)| icc timings (ms) | clang timings (ms)|\r\n---------------------------------|------------------|------------------|-------------------|\r\nnaive                            |   3.19 +-  0.02  |   3.19 +-  0.03  |   3.19 +-  0.00   | \r\nchunked                          |   3.19 +-  0.02  |   3.19 +-  0.01  | \t 3.19 +-  0.02   |\r\ncompiler_vectorized_chunked      |   3.74 +-  0.02  |   3.81 +-  0.01  | \t 4.75 +-  0.00   |\r\nintrinsics_chunked               |   3.19 +-  0.03  |   3.19 +-  0.03  | \t 3.19 +-  0.02   |\r\nintrinsics_chunked_unroll4       |   3.27 +-  0.02  |   3.21 +-  0.03  | \t 3.19 +-  0.02   |\r\npairwise_ispc                    |   3.19 +-  0.02  |   3.19 +-  0.02  | \t 3.19 +-  0.00   |\r\n\r\nExpectedly, C is much faster than any numba/cython/f2py combination can\r\nget you. For comparison, the fastest timings with numba/cython/f2py was around 9 ms. \r\nSee [here](https://jakevdp.github.io/blog/2013/06/15/numba-vs-cython-take-2/) for\r\na detailed blog post. \r\n\r\nNote, that you have CPU frequency scaling on *and* do not run the tests for long enough,\r\nthen you might be fooled into thinking that the tests take longer to run (simply because\r\nthe cpu is running at a lower frequency). I found out by ``diff``ing between \r\nlinux ``perf`` output for slow and fast runs.  \r\n\r\n\r\n## Pairwise Histogram\r\n\r\nIn progress. Ultimately, the repo will contain a similar idea, just for the\r\nhistograms of all pairwise distances. The fastest codes will probably get\r\nmigrated into my correlation function routines [here](https://bitbucket.org/manodeep/corrfunc/).\r\n\r\n\r\nFunction                         |  gcc timings (ms)| icc timings (ms) | clang timings (ms)| \r\n---------------------------------|------------------|------------------|-------------------|\r\nnaive                            |  2.12 +-  0.02   |   2.23 +-  0.03  |   1.97 +-  0.00   |\r\nchunked                          |  1.42 +-  0.01   |   1.50 +-  0.01  | \t 1.44 +-  0.01   |\r\ncompiler_vectorized_chunked      |  2.19 +-  0.02   |   2.21 +-  0.01  | \t 1.90 +-  0.01   |\r\nintrinsics_chunked               |  0.60 +-  0.00   |   0.68 +-  0.01  | \t 0.71 +-  0.00   |\r\nintrinsics_chunked_unroll2       |  0.55 +-  0.01   |   0.67 +-  0.02  |   0.63 +-  0.01   |\r\n\r\n# Author\r\n\r\nPairwise is written/maintained by Manodeep Sinha. Please contact the [author](mailto:manodeep@gmail.com) in\r\ncase of any issues.\r\n\r\n# Citing the code\r\n\r\nIf you use the code, please cite using the Zenodo DOI\r\n\r\n# LICENSE\r\n\r\nPairwise is released under the MIT license. Basically, do what you want\r\nwith the code including using it in commercial application.\r\n\r\n# Project URL\r\n\r\n* website (https://manodeep.github.io/pairwise) \r\n* version control (https://github.com/manodeep/pairwise)\r\n","google":"UA-53726906-3","note":"Don't delete this file! It's used internally to help with page regeneration."}
